<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">


  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;400;600&display=swap" rel="stylesheet">
  <title> Digital Portfolio </title>
  <link rel="stylesheet" href="../CS-II/apa.css" media="screen" />
</head>


<div class="header">
  <button type="button" onclick="window.location.href = '../index.html';">About Me</button><button <button
    onclick="window.location.href = 'Projects/Optimal Sort.html';">Optimal Sort</button><button
    onclick="window.location.href = 'Projects/Business Plan/index.html';">Business Plan</button><button
    onclick="window.location.href = 'Projects/Business Plan/considered.html';">Considered ISPs</button><button
    onclick="window.location.href = 'Projects/ISP/index.html';">ISP</button>
</div>

<body>

  <div class="main">

  <h2>Merge Sort</h2>
  <p>
    Merge Sort works by repeatedly dividing the unsorted list into smaller halves until each sublist contains only one
    element. Then, it merges these sublists back together in a sorted order. It's like breaking down a problem into
    smaller parts, solving them, and then combining the solutions to get the final result.
  </p>
  <h2>Example with cards (assume face cards are 11, 12, and 13):</h2>
  <p>
    First, you take your deck of cards and split it into two equal halves. Now, you have two smaller stacks. Next, keep
    splitting up each smaller stack until all of your stacks contain one card each. Then, you look at the first card in
    each small stack and the one next to it. Whateverâ€™s smaller goes first in a new deck. The other first card gets
    evaluated with the next card. You keep doing this until you have successfully ordered all the cards in both stacks
    in a new stack. You end up with a larger sorted stack.
  </p>
  <p>
    Repeat: You keep doing these steps - sorting and merging - until all the cards are in a single pile, and they're in
    the correct order from smallest to largest.
  </p>

  <h2>Quicksort</h2>
  <p>
    Quicksort chooses a 'pivot' element from the list and partitions the other elements into two sublists: those less
    than the pivot and those greater than the pivot. It then recursively sorts the sublists. The sorted sublists are
    then combined to get the final sorted list. It's like organizing things by picking a reference point, putting
    smaller things on one side and bigger things on the other, then repeating the process for those smaller and bigger
    groups.
  </p>
  <h2>Example with cards (assume face cards are 11, 12, and 13):</h2>
  <p>
    First, you pick a card, it doesn't matter which one. This is the pivot. Now, you look at each of the other cards and
    decide whether they are smaller or bigger than the pivot. You create two separate groups: one for the cards smaller
    than the pivot and another for the cards larger than the pivot. Note: if your pivot is equal to another element in
    the array, that element could go to either group; in the end, the array will still be sorted. You then take each of
    these two groups and apply the same process to them. You pick a new pivot for each group and divide the cards in
    that group into even smaller groups - one for smaller cards and one for larger cards. You keep doing this process of
    choosing a pivot, dividing the cards, and sorting them into smaller groups until every group has only one card. At
    this point, every card is in its correct place because you've compared and arranged them multiple times. Finally,
    you gather all the cards back together in order. The ones in the smaller groups come before the pivot, and the ones
    in the larger groups come after. Now, all the cards are sorted from smallest to largest.
  </p>
  <h2>Example:</h2>
  <p>1,5,3,4,6 Pivot 4<br>
    1,3 and 5,6 Pivots: 3 and 5<br>
    1 and 6<br>
    Now recombine with the pivots<br>
    1,3 and 5,6<br>
    1,3,4,5,6
  </p>

  <h2>Heapsort</h2>
  <p>
    Heap sort is a sorting algorithm that uses a binary heap data structure to repeatedly extract the maximum (or
    minimum) element from the data and place it in the sorted portion of the array until the entire array is sorted. A
    binary tree contains all elements of the array. In a max-heap, the largest element is at the root. In a min-heap,
    the smallest value is at the root. Think of it as organizing items like a priority queue, where the biggest (or
    smallest) item is dealt with first, and this process continues.
  </p>
  <h2>Example with cards (assume face cards are 11, 12, and 13):</h2>
  <p>
    First, you bring the largest card (13) to the top. Then put the biggest card into a separate sorted stack. Then find
    the next biggest number (12) and put it at the top of the deck. Then put in the next biggest number after the
    largest in the other deck. Keep doing this until the unsorted deck is empty, and the sorted deck has all cards in
    order. Note: This can also be done by finding the smallest number instead of the biggest. The concept remains the
    same.
  </p>

  <h2>Time Complexity</h2>
  <p>
    n stands for the size of the array being sorted.
  </p>
  <h1>Merge Sort:</h1>
  <ul>
    <li>Best-case time complexity: O(n log n)</li>
    <li>Worst-case time complexity: O(n log n)</li>
    <li>Average-case time complexity: O(n log n)</li>
  </ul>

  <h1>Heap Sort:</h1>
  <ul>
    <li>Best-case time complexity: O(n log n)</li>
    <li>Worst-case time complexity: O(n log n)</li>
    <li>Average-case time complexity: O(n log n)</li>
  </ul>

  <h1>Quick Sort:</h1>
  <ul>
    <li>Best-case time complexity: O(n log n)</li>
    <li>Worst-case time complexity: O(n^2)</li>
    <li>Average-case time complexity: O(n log n)</li>
  </ul>

  <h1>Overall</h1>
  <p>
    All three sorts have the same best and average case time complexity. However, QuickSort can have the worst time if
    picking the pivots is not implemented correctly.
  </p>

  <h2>Space Complexity</h2>
  <h1>Merge Sort:</h1>
  <p>Space Complexity: O(n). The space increases proportionally to the size of the input array.</p>

  <h1>Heap Sort:</h1>
  <p>Space Complexity: O(1). Heap Sort uses a binary tree, so the space needed remains constant.</p>

  <h1>Quick Sort:</h1>
  <p>Space Complexity: O(log n) to O(n). Quick sort is usually better than merge sort and can be better than Heap sort
    depending on the size of the input. However, it ultimately depends on how well the algorithm
 
    <h2>Bibliography:</h2>
    <p class="hangingindent">GeeksforGeeks. (2023a, July 6). Merge sort - data structure and algorithms tutorials. GeeksforGeeks. https://www.geeksforgeeks.org/merge-sort/ 
    </p>
    <p class="hangingindent"> GeeksforGeeks. (2023b, July 25). Heap sort - data structures and algorithms tutorials. GeeksforGeeks. https://www.geeksforgeeks.org/heap-sort/ 
  </p>
  <p class="hangingindent"> OpenAI. (2023, August 28). Explanation of Sorting Algorithms and Their Performance. ChatGPT. 
  </p>
  </div>
</body>
  </html>